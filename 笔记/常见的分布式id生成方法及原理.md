# UUID

**优点：**

生成足够简单，本地生成无网络消耗，具有唯一性


 **缺点：**

1、无序的字符串，不具备趋势自增特性,不适用于实际的业务需求。像用作订单号UUID这样的字符串没有丝毫的意义

2、长度过长，16 字节128位 ，存储以及查询对MySQL的性能消耗较大, （ MySQL官方明确建议主键要尽量越短越好）

3、既然分布式Id是主键,然后主键是包含索引的, innoDB的索引是通过B+树来实现的,每一次新的UUID数据的插入,为了查询的优化,都会对索引底层的B+树进行修改,因为UUID是无序的,所以每一次UUID数据的插入都会对B+树进行很大的修改,这一点很不好.插入完全无序,不但会导致一些中间节点产生分裂,也会白白创造出很多不饱和的节点,这样大大降低了数据库插入的性能,所以不推荐用作分布式ID。

# **基于数据库自增**ID

基于数据库的auto_increment自增ID完全可以充当分布式ID，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下, 当我们需要一个ID的时候，向表中插入一条记录返回主键ID，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！

**优点：**

实现简单，ID单调自增，数值类型查询速度快

**缺点：**

DB单点存在宕机风险，无法扛住高并发场景

# **基于数据库集群模式**

前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。

**优点：**

•解决DB单点问题

**缺点：**

•不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。

# **基于数据库的号段模式**

号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：

![image-20211019170309669](C:\Users\liqian477\AppData\Roaming\Typora\typora-user-images\image-20211019170309669.png)



biz_type ：代表不同业务类型

max_id ：当前最大的可用id

step ：代表号段的长度

version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性

等这批号段ID用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id= max_id + step，update成功则说明新号段获取成功，新的号段范围是(max_id ,max_id +step]

update id_generator set max_id **=** #**{**max_id**+**step**},** version **=** version **+** 1 where  version **=** # **{**version**}** and biz_type **=** XXX

由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。

# 基于Redis模式

Redis也同样可以实现，原理就是利用redis的 incr命令实现ID的原子性自增。

用redis实现需要注意一点，要考虑到redis持久化的问题。redis有两种持久化方式RDB和AOF

RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。

AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。

# 基于雪花算法（Snowflake）模式

Twitter开源

SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图:

![image-20211019182752453](C:\Users\liqian477\AppData\Roaming\Typora\typora-user-images\image-20211019182752453.png)

1、1bit，不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。

2、41bit-时间戳

41位可以表示2^41-1个数字，如果只用来表示正整数，可以表示的数值范围是：0 - (2^41 -1)，这里减去1的原因就是因为数值范围是从0开始计算的，而不是从1开始的。

这里的单位是毫秒，所以41位就可以表示2^41-1个毫秒值，这样转化成单位年则是 (2^41-1)/(1000 * 60 * 60 * 24 * 365) = 69

3、10bit-工作机器id，用来记录工作机器id。

\- 可以部署在多个节点，包括5位datacenterId和5位workerId

-5位（bit）可以表示的最大正整数是，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId

4、12bit-序列号，序列号，用来记录同毫秒内产生的不同id。

\- 12位（bit）可以表示的最大正整数是，即可以用0、1、2、3、....4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号。

这种方式的优缺点是：

## **优点**：

毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。

不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。

可以根据自身业务特性分配bit位，非常灵活。

## **缺点**：

强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

## **存在的问题**

1、时间回拨问题：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现数据重复

2、机器id分配及回收问题：目前机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果改机器宕机了，对应的workerId分配后的回收问题

3、机器id上限：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。

##  **机器**id上限问题：

该问题在业内都没有处理，也就是说如果采用雪花算法，则必定会存在该问题，但是该问题也只有需要大量的业务机器共享的场景才会出现，这种情况，采用其他非雪花算法的方案也未尝不可。









