# JSF

跟dubbo差不多

# 接口设计原则

出外部调用接口时记得做接口防止重复提交

接口入参尽量简单, 嵌套尽量要少, 可以减少序列化的耗时

不要使用重载方法

# 幂等性

对某一接口, 任意多次的重复调用产生的效果应该是一样的, 这就是幂等性, 出接口时要记得做幂等校验, 尤其是一些写接口

## 需要考虑幂等性的场景

前端重复提交: 用户可能会在短时间内多次点击造成重复提交

接口超时重试: 接口性能差或出现网络波动时可能导致重复调用接口

MQ重复消费: 在RocketMQ中, 如果消费方抛出异常会导致消息重复消费, 此时需要考虑幂等性校验

**另外任何与金钱有关的接口都需要做幂等性校验**

# 死亡结点

## 真死和假死

真死: provider端口挂了, consumer和provider长连接断开, consumer不会调用死亡的provider

假死: provider端口还在, 可能因为网络问题注册中心拿不到provider的心跳, 但此时consumer和provider的长连接还在, consumer还是可以调用假死的接口

## 删除死亡结点

线上默认8小时后删除, 测试环境默认5分钟后删除

# 新增接口

新增的接口需要在jsf管理端提交新增接口的审批, 在接口中新增方法不需要审批

# MessagePack

这是jsf默认的序列化方式

## 注意

接口出入参对象里新增的字段都要加在最后面, 且不能更改字段的顺序, 否则会出现序列化异常

因为jsf在使用MessagePack进行序列化和反序列化时是严格按照字段的字段的顺序进行的

# jsf结构间关系

consumer每隔30s向服务端发送心跳, 检测长连接情况和服务端健康状况



